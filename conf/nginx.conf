worker_processes  10;
events {
  worker_connections  1024;
}

env JWT_SECRET;

http {
  server {
    listen       3891;
    server_name _;
    srcache_response_cache_control off;
    location / {
      resolver 8.8.8.8;
      set $key $http_host$request_uri;
      if ( $http_echo_key ) {
        set $key $http_echo_key;
      }
      if ( $http_echo_invalidate ) {
        set $key $http_echo_key;
      }
      set_escape_uri $escaped_key $key;

      srcache_fetch GET /v0.1/cache/get key=$escaped_key;

      set $expire 0;
      if ( $http_echo_expire ) {
        set $expire $http_echo_expire;
      }
      if ( $http_echo_cacheable ) {
        srcache_store PUT /v0.1/cache/put key=$escaped_key&expire=$expire;
      }

      proxy_set_header Host $http_host;
      proxy_pass http://$http_host$request_uri;
      proxy_buffers   256 4k;
    }

    location = /v0.1/cache/get {
      set $redis_key object:$arg_key;
      redis_pass 127.0.0.1:7777;
    }

    location = /v0.1/cache/put {
      set $key $arg_key;
      set $expire $arg_expire;
      redis2_query set object:$key $echo_request_body;
      redis2_query expire $key $expire;
      redis2_pass 127.0.0.1:7777;
    }

    location = /v0.1/cache/del {
      set $keys $arg_keys;
      set $query 'EVAL "return redis.call(\'del\', unpack(redis.call(\'keys\', \'object:$keys\')))" 0\r\n';
      redis2_raw_query $query;
      redis2_pass 127.0.0.1:7777;
    }

    location = /v0.1/cache/observe {
      content_by_lua_block {
        local redis = require "resty.redis"
        local red = redis:new()

	red:set_timeout(1000)
	local ok, err = red:connect("127.0.0.1", 7777)
	if not ok then
	  ngx.say("failed to connect: ", err)
	  return
        end

	local weight = 0
	if ngx.var.arg_weight ~= nil then
	  weight = ngx.var.arg_weight
        end	

	local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
	if not ok then
	  ngx.say("failed to add observable: ", err)
	  return
        end
	ngx.say("done")
      }
    }

    location = /v0.1/cache/invalidate {
      content_by_lua_block {
        local redis = require "resty.redis"
        local red = redis:new()

	red:set_timeout(1000)
	local ok, err = red:connect("127.0.0.1", 7777)
	if not ok then
	  ngx.say("failed to connect: ", err)
	  return
        end

	for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do 
	  red:del(k) 
	end
	ngx.say("done")
      }
    }

    location = /v0.1/cache/notify {
      content_by_lua_block {
        local redis = require "resty.redis"
        local red = redis:new()

	red:set_timeout(1000)
	local ok, err = red:connect("127.0.0.1", 7777)
	if not ok then
	  ngx.say("failed to connect: ", err)
	  return
        end

	local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
	if patterns == nil then
	  ngx.say("nothing to delete", err)
	  return
	end

	for i,v in pairs(patterns) do
		for _,k in ipairs(red:keys('object:' .. v)) do 
			red:del(k) 
		end
	end
	ngx.say("done")
      }
    }

    location = /v0.1/cache/keys {
      set $pattern $arg_pattern;
      redis2_query keys $pattern;
      redis2_pass 127.0.0.1:7777;
    }
  }

  lua_package_path "/Users/pteyer/echo/lualib/?.lua;;";
  server {
    listen 8080;

    location / {
      default_type text/html;
      content_by_lua '
        ngx.say("<p>hello, unprotected lua world</p>")
        ';
    }

    location /secure/ {
      access_by_lua_file /Users/pteyer/echo/lualib/bearer.lua;

      default_type text/plain;
      echo "<p>i am protected by jwt<p>";
    }
  }

}
