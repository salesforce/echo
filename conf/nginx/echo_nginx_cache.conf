  location = /.cache/objects/get {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local key = ngx.var.arg_key
      if key == nil then
        ngx.say("missing query string parameter 'key'.")
        return
      end
      if string.sub(key,1,string.len('object:')) ~= 'object:' then
        key = 'object:' .. key
      end

      local value, err = red:get(key)
      if not value or value == ngx.null then
        ngx.status = ngx.HTTP_NOT_FOUND
        return
      else
        ngx.say(value)
        return
      end
    }
  }

  location = /.cache/objects/put {
    internal;
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local body = ngx.var.echo_request_body

      local echo_invalidate = string.match(body, '\r\nEcho%-Invalidate: (.-)\r\n')
      local echo_key = string.match(body, '\r\nEcho%-Key: (.-)\r\n')
      local echo_expire = string.match(body, '\r\nEcho%-Expire: (.-)\r\n')
      local echo_observe = string.match(body, '\r\nEcho%-Observe: (.-)\r\n')
      local echo_notify = string.match(body, '\r\nEcho%-Notify: (.-)\r\n')

      -- key to store in cache
      local key = ngx.var.arg_key
      if echo_key ~= nil then
        key = echo_key
      end

      if string.sub(key,1,string.len('object:')) ~= 'object:' then
        key = 'object:' .. key
      end

      -- invalidation
      if echo_invalidate ~= nil then
        for _,k in ipairs(red:keys('object:' .. echo_invalidate)) do
          red:del(k)
        end
      end

      -- observe
      if echo_observe ~= nil then
        red:sadd('observable:' .. echo_observe, key)
      end

      -- notify observerable
      if echo_notify ~= nil then
        for _,k in pairs(red:smembers('observable:' .. echo_notify)) do
          red:del(k)
        end
        -- remove observable
        red:del('observable:' .. echo_notify)
      end

      -- store the response body if method is get or head
      if ngx.var.arg_method == 'GET' or ngx.var.arg_method == 'HEAD' then
        red:set(key, body)
      end

      -- add expiry
      local exipre = 3600
      if echo_expire ~= nil then
        expire = echo_expire
      end
      red:expire(key, expire)

      ngx.status = ngx.HTTP_OK
      return
    }
  }

  location = /.cache/invalidate {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local count = 0
      for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do
        red:del(k)
        count = count + 1
      end
      ngx.say("deleted " .. count .. " entries.")
    }
  }

  location = /.cache/observe {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local weight = 0
      if ngx.var.arg_weight ~= nil then
        weight = ngx.var.arg_weight
      end

      local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
      if not ok then
        ngx.say("failed to add observable: ", err)
        return
      end
      ngx.say("done")
    }
  }

  location = /.cache/notify {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
      if patterns == nil then
        ngx.say("nothing to delete", err)
      return
      end

      local count = 0
      for i,v in pairs(patterns) do
        for _,k in ipairs(red:keys('object:' .. v)) do
          red:del(k)
          count = count + 1
        end
      end
      ngx.say("deleted " .. count .. " entries.")
    }
  }

  location = /.cache/keys {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      for k, v in ipairs(red:keys(ngx.var.arg_pattern)) do
        ngx.say(k)
        ngx.say(v)
      end
    }
  }

