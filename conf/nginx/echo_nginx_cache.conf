  location = /.cache/objects/get {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local key = ngx.var.arg_key
      if key == nil then
        ngx.say("missing query string parameter 'key'.")
        return
      end
      if string.sub(key,1,string.len('object:')) ~= 'object:' then
        key = 'object:' .. key
      end

      local value, err = red:get(key)
      if not value or value == ngx.null then
        ngx.status = ngx.HTTP_NOT_FOUND
        return
      else
        ngx.say(value)
        return
      end
    }
  }

  location = /.cache/objects/put {
    internal;
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local key = ngx.var.arg_key
      if key == nil then
        ngx.say("missing query string parameter 'key'.")
        return
      end
      if (string.sub(key,1,string.len('object:'))~='object:') then
        key = 'object:' .. key
      end

      local value = ngx.var.echo_request_body
      red:set(key, value)

      local exipre = ngx.var.arg_expire
      if  expire == nil then
        expire = 3600
      end
      red:expire(key, expire)
      ngx.status = ngx.HTTP_OK
      ngx.say('done')
      return
    }
  }

  location = /.cache/del {
    set $keys $arg_keys;
    set $query 'EVAL "return redis.call(\'del\', unpack(redis.call(\'keys\', \'object:$keys\')))" 0\r\n';
    redis2_raw_query $query;
    redis2_pass 127.0.0.1:7777;
  }

  location = /.cache/observe {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local weight = 0
      if ngx.var.arg_weight ~= nil then
        weight = ngx.var.arg_weight
      end

      local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
      if not ok then
        ngx.say("failed to add observable: ", err)
        return
      end
      ngx.say("done")
    }
  }

  location = /.cache/invalidate {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local count = 0
      for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do
        red:del(k)
        count = count + 1
      end
      ngx.say("deleted " .. count .. " entries.")
    }
  }

  location = /.cache/notify {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
      if patterns == nil then
        ngx.say("nothing to delete", err)
      return
      end

      local count = 0
      for i,v in pairs(patterns) do
        for _,k in ipairs(red:keys('object:' .. v)) do
          red:del(k)
          count = count + 1
        end
      end
      ngx.say("deleted " .. count .. " entries.")
    }
  }

  location = /.cache/keys {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      for k, v in ipairs(red:keys(ngx.var.arg_pattern)) do
        ngx.say(k)
        ngx.say(v)
      end
    }
  }

