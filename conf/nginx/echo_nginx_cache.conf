location = /.cache/objects/get {
  internal;
  content_by_lua_block {

    -- only respond to get and head methods
    if ngx.var.arg_method ~= 'GET' and ngx.var.arg_method ~= 'HEAD' then
      ngx.log(ngx.INFO, 'skipping cache lookup for method ' .. ngx.var.arg_method)
      ngx.status = ngx.HTTP_NOT_FOUND
      return
    end

    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
      ngx.log(ngx.INFO, 'failed to connect to Redis' .. err)
      return
    end

    -- construct key for object
    local key = 'object:' .. ngx.var.arg_key

    -- return value from cache if found, 404 otherwise
    local value = red:get(key)
    if not value or value == ngx.null then
      ngx.status = ngx.HTTP_NOT_FOUND
      return
    end
    ngx.say(value)
    return
  }
}

location = /.cache/objects/put {
  internal;
  content_by_lua_block {

    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
      ngx.log(ngx.INFO, 'failed to connect to Redis' .. err)
      return
    end

    -- get response body
    local body = ngx.var.echo_request_body

    -- extract echo parameters
    local echo_key = string.match(body, '\r\nEcho%-Key: (.-)\r\n')
    local echo_invalidate = string.match(body, '\r\nEcho%-Invalidate: (.-)\r\n')
    local echo_expire = string.match(body, '\r\nEcho%-Expire: (.-)\r\n')
    local echo_observe = string.match(body, '\r\nEcho%-Observe: (.-)\r\n')
    local echo_notify = string.match(body, '\r\nEcho%-Notify: (.-)\r\n')

    -- key to store in cache
    local key = 'object:' .. ngx.var.arg_key
    if echo_key ~= nil then
      key = 'object:' .. echo_key
    end

    -- invalidation
    if echo_invalidate ~= nil then
      ngx.log(ngx.INFO, 'echo-invalidate for pattern ' .. echo_invalidate)
      for _,k in ipairs(red:keys('object:' .. echo_invalidate)) do
        ngx.log(ngx.INFO, 'invalidating key ' .. k)
        red:del(k)
      end
    end

    -- observe
    if echo_observe ~= nil then
      ngx.log(ngx.INFO, 'adding key ' .. key .. ' to observable ' .. echo_observe)
      red:sadd('observable:' .. echo_observe, key)
    end

    -- notify observerable
    if echo_notify ~= nil then
      ngx.log(ngx.INFO, 'echo-notify for observable ' .. echo_notify)
      for _,k in pairs(red:smembers('observable:' .. echo_notify)) do
        ngx.log(ngx.INFO, 'invalidating key ' .. k)
        red:del(k)
      end
      -- remove observable
      ngx.log(ngx.INFO, 'removing observable ' .. echo_notify)
      red:del('observable:' .. echo_notify)
    end

    -- store the response body if method is get or head
    if ngx.var.arg_method == 'GET' or ngx.var.arg_method == 'HEAD' then

      ngx.log(ngx.INFO, 'storing object for key ' .. key)
      red:set(key, body)

      -- add expiry
      local expire = 3600
      if echo_expire ~= nil then
        expire = echo_expire
      end

      ngx.log(ngx.INFO, 'expiring key ' .. key .. ' in ' .. expire .. ' seconds')
      red:expire(key, expire)
    end


    ngx.status = ngx.HTTP_OK
    return
  }
}

location = /.cache/invalidate {
  content_by_lua_block {
    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
      ngx.say("failed to connect: ", err)
      return
    end

    local count = 0
    for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do
      red:del(k)
      count = count + 1
    end
    ngx.say("deleted " .. count .. " entries.")
  }
}

location = /.cache/observe {
  content_by_lua_block {
    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
      ngx.say("failed to connect: ", err)
      return
    end

    local weight = 0
    if ngx.var.arg_weight ~= nil then
      weight = ngx.var.arg_weight
    end

    local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
    if not ok then
      ngx.say("failed to add observable: ", err)
      return
    end
    ngx.say("done")
  }
}

location = /.cache/notify {
  content_by_lua_block {
    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
    ngx.say("failed to connect: ", err)
    return
    end

    local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
    if patterns == nil then
      ngx.say("nothing to delete", err)
    return
    end

    local count = 0
    for i,v in pairs(patterns) do
      for _,k in ipairs(red:keys('object:' .. v)) do
        red:del(k)
        count = count + 1
      end
    end
    ngx.say("deleted " .. count .. " entries.")
  }
}

location = /.cache/keys {
  content_by_lua_block {
    local redis = require "resty.redis"
    local red = redis:new()

    red:set_timeout(1000)
    local ok, err = red:connect("unix:/tmp/echo.sock")
    if not ok then
      ngx.say("failed to connect: ", err)
      return
    end

    for k, v in ipairs(red:keys(ngx.var.arg_pattern)) do
      ngx.say(k)
      ngx.say(v)
    end
  }
}

