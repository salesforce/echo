  location = /.cache/objects/get {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local key = ngx.var.arg_key
      if key == nil then
        ngx.say("missing query string parameter 'key'.")
        return
      end
      if (string.sub(key,1,string.len('object:'))~='object:') then
        key = 'object:' .. key
      end

      local value, err = red:get(key)
      if not value or value == ngx.null then
        ngx.status = ngx.HTTP_NOT_FOUND
        return
      else
        ngx.say(value)
        return
      end
      return
    }
  }

  location = /.cache/objects/put {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
        ngx.say("failed to connect: ", err)
        return
      end

      local key = ngx.var.arg_key
      if key == nil then
        ngx.say("missing query string parameter 'key'.")
        return
      end
      if (string.sub(key,1,string.len('object:'))~='object:') then
        key = 'object:' .. key
      end

      local value = ngx.var.arg_body
      red:set(key, value)
      ngx.status = ngx.HTTP_OK
      ngx.say('done')
      return
    }
  }

  location = /.cache/del {
    set $keys $arg_keys;
    set $query 'EVAL "return redis.call(\'del\', unpack(redis.call(\'keys\', \'object:$keys\')))" 0\r\n';
    redis2_raw_query $query;
    redis2_pass 127.0.0.1:7777;
  }

  location = /.cache/observe {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local weight = 0
      if ngx.var.arg_weight ~= nil then
      weight = ngx.var.arg_weight
      end

      local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
      if not ok then
        ngx.say("failed to add observable: ", err)
        return
      end
      ngx.say("done")
    }
  }

  location = /.cache/invalidate {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do
        red:del(k)
      end
      ngx.say("done")
    }
  }

  location = /.cache/notify {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
      if patterns == nil then
      ngx.say("nothing to delete", err)
      return
      end

      for i,v in pairs(patterns) do
      for _,k in ipairs(red:keys('object:' .. v)) do
      red:del(k)
      end
      end
      ngx.say("done")
    }
  }

  location = /.cache/keys {
    set $pattern $arg_pattern;
    redis2_query keys $pattern;
    redis2_pass 127.0.0.1:7777;
  }

