map $upstream_http_location $redirect_uri {
  "~http://[^/]+/(?<location_uri>.*)$" "$location_uri";
}
upstream gus {
  server 96.43.144.112:443;
}
server {
  listen       443 default ssl;
  server_name gs0.salesforce.com;
  ssl_certificate           /tmp/cert.crt;
  ssl_certificate_key       /tmp/cert.key;
  ssl on;
  ssl_session_cache  builtin:1000  shared:SSL:10m;
  #ssl_protocols  SSLv3 TLSv1;
  #ssl_ciphers ALL:!ADH:!EXPORT56:RC4+RSA:+HIGH:+MEDIUM:+LOW:!SSLv2:+EXP;
  proxy_ssl_session_reuse off;
  ssl_verify_client off;
  ssl_prefer_server_ciphers on;
  error_log        /tmp/gus.error debug;
  access_log       /tmp/gus.access.log;
  srcache_response_cache_control off;
  location / {

    resolver 8.8.8.8;
    set $key $http_host$request_uri;
    if ( $http_echo_key ) {
      set $key $http_echo_key;
    }
    if ( $http_echo_invalidate ) {
      set $key $http_echo_key;
    }
    set_escape_uri $escaped_key $key;

    srcache_fetch GET /v0.1/cache/get key=$escaped_key;

    set $expire 0;
    if ( $http_echo_expire ) {
      set $expire $http_echo_expire;
    }
    if ( $http_echo_cacheable ) {
      srcache_store PUT /v0.1/cache/put key=$escaped_key&expire=$expire;
    }

    proxy_intercept_errors on;
    error_page 301 302 = @handler;

    proxy_ssl_server_name on;
    #proxy_redirect https://gs0.salesforce.com https://127.0.0.1;
    proxy_redirect              off;
    proxy_pass https://gus;
      proxy_set_header Host $http_host;
    proxy_set_header X-Real-IP  $remote_addr;
    proxy_set_header X-Forwarded-For $remote_addr;
    proxy_buffers   256 4k;
  }

  location @handler {
    rewrite ^ /$redirect_uri break;
    proxy_pass https://gus;
  }

  location = /v0.1/cache/get {
    set $redis_key object:$arg_key;
    redis_pass 127.0.0.1:7777;
  }

  location = /v0.1/cache/put {
    set $key $arg_key;
    set $expire $arg_expire;
    redis2_query set object:$key $echo_request_body;
    redis2_query expire $key $expire;
    redis2_pass 127.0.0.1:7777;
  }

  location = /v0.1/cache/del {
    set $keys $arg_keys;
    set $query 'EVAL "return redis.call(\'del\', unpack(redis.call(\'keys\', \'object:$keys\')))" 0\r\n';
    redis2_raw_query $query;
    redis2_pass 127.0.0.1:7777;
  }

  location = /v0.1/cache/observe {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local weight = 0
      if ngx.var.arg_weight ~= nil then
      weight = ngx.var.arg_weight
      end

      local ok, err = red:zadd(ngx.var.arg_key, weight, ngx.var.arg_pattern);
      if not ok then
      ngx.say("failed to add observable: ", err)
      return
      end
      ngx.say("done")
    }
  }

  location = /v0.1/cache/invalidate {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      for _,k in ipairs(red:keys('object:' .. ngx.var.arg_keys)) do
      red:del(k)
      end
      ngx.say("done")
    }
  }

  location = /v0.1/cache/notify {
    content_by_lua_block {
      local redis = require "resty.redis"
      local red = redis:new()

      red:set_timeout(1000)
      local ok, err = red:connect("127.0.0.1", 7777)
      if not ok then
      ngx.say("failed to connect: ", err)
      return
      end

      local patterns, err = red:zrange(ngx.var.arg_key, 0, -1);
      if patterns == nil then
      ngx.say("nothing to delete", err)
      return
      end

      for i,v in pairs(patterns) do
      for _,k in ipairs(red:keys('object:' .. v)) do
      red:del(k)
      end
      end
      ngx.say("done")
    }
  }

  location = /v0.1/cache/keys {
    set $pattern $arg_pattern;
    redis2_query keys $pattern;
    redis2_pass 127.0.0.1:7777;
  }
}
